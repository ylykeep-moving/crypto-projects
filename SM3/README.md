#  实验报告部分：SM3 哈希函数实现与优化解析

------

# 一、实验目的

1. 理解 SM3 哈希算法的结构与流程
2. 使用 C++ 实现 SM3 哈希算法
3. 在 Visual Studio 中测试 SM3 的性能
4. 进行优化与吞吐量测试，分析不同优化策略的效果

------

# 二、SM3 算法原理解析

## 2.1 SM3 简介

SM3 是中国国家密码管理局于 2010 年发布的哈希函数标准，具有如下特点：

- 输出长度：256 位（32 字节）
- 消息分组：512 位（64 字节）
- 安全性：与 SHA-256 相当，设计上使用 Merkle–Damgård 构造

## 2.2 算法结构

SM3 由以下几部分组成：

### 1. **初始向量（IV）**

```text
V0 = 7380166f 4914b2b9 172442d7 da8a0600
     a96f30bc 163138aa e38dee4d b0fb0e4e
```

### 2. **填充**

- 补 1
- 补 0 直到消息长度 ≡ 448 mod 512
- 最后追加原始长度（64 位）

### 3. **消息扩展**

将 512 位消息块扩展为 132 个字：

- `W[0..67]`: 主扩展
- `W1[0..63] = W[i] ⊕ W[i+4]`: 辅助扩展

使用非线性函数 `P1(x) = x ⊕ (x ≪ 15) ⊕ (x ≪ 23)`

### 4. **压缩函数 CF**

对每个分组进行 64 次迭代：

- 状态变量：A~H（共 8 个 32 位）

- 非线性布尔函数：

  ```
  FF_j(x, y, z) = 
      x ^ y ^ z           (j ∈ [0,15])
      (x & y) | (x & z) | (y & z) (j ∈ [16,63])
  
  GG_j(x, y, z) = 
      x ^ y ^ z           (j ∈ [0,15])
      (x & y) | (~x & z)  (j ∈ [16,63])
  ```

- `SS1 = ((A ≪ 12) + E + (T_j ≪ j)) ≪ 7`

- `SS2 = SS1 ⊕ (A ≪ 12)`

- `TT1 = FF_j(...) + D + SS2 + W1[j]`

- `TT2 = GG_j(...) + H + SS1 + W[j]`

每轮更新 A~H 值，并将新值异或到中间状态向量 `V[i+1] = V[i] ⊕ CF(...)`

------

# 三、C++ 实现细节

## 3.1 数据结构设计

- `typedef uint32_t u32;` 为 32 位变量简化表达
- 使用 `std::vector<u8>` 存储消息与哈希输出
- 避免指针操作，提升安全性

## 3.2 模块划分

- `sm3()`：主哈希函数
- `sm3_compress()`：压缩函数，对 64 字节块处理
- `FF()`, `GG()`, `P0()`, `P1()`：逻辑/置换函数

------

# 四、优化策略与性能提升分析

## 4.1 编译优化（基础）

| 优化项          | VS 设置                        |
| --------------- | ------------------------------ |
| 最大速度优化    | `Release` 模式，`/O2`          |
| 启用本地指令集  | `C/C++ → Codegen → /arch:AVX2` |
| 内联函数/宏展开 | 函数 `inline` + 编译器优化     |

## 4.2 算法优化

| 优化点               | 描述                                                  |
| -------------------- | ----------------------------------------------------- |
| **循环展开**         | 减少 `if` 分支判断，提高流水线效率                    |
| **W/W1 缓存复用**    | 避免多次计算相同中间值                                |
| **状态变量寄存器化** | A~H 全部保持为局部变量，减少内存写入                  |
| **内存填充对齐**     | 消息使用 `std::vector<u8>` 一次性填充，提高缓存局部性 |

## 4.3 多轮测试统计吞吐量

测试方式：

```cpp
auto start = high_resolution_clock::now();
for (int i = 0; i < N; ++i) sm3(data, len);
auto end = high_resolution_clock::now();
```

吞吐量计算公式：

```
Throughput = Total_Data_Size / Duration_Seconds (MB/s)
```

------

# 五、性能测试结果（单线程）

![实验结果](D:\crypto-projects\SM2\实验结果.png)

可见我们成功的运行了，但是吞吐率并不是很高，我们尝试使用编译器优化：

将debug模式换成了release模式：

###  1. 启用了高级优化选项（比如 `/O2`）

| 优化类型                      | 作用                                  |
| ----------------------------- | ------------------------------------- |
| **常量折叠**                  | `x = 2+3;` 会在编译期直接变成 `x = 5` |
| **函数内联**                  | 避免频繁函数调用开销                  |
| **循环展开与合并**            | 减少循环次数、分支预测冲突            |
| **寄存器优化**                | 把频繁变量存在寄存器里，避免内存访问  |
| **指令重排 / 向量化（SIMD）** | 提高流水线效率，减少指令数            |

------

###  2. Debug 模式保留了**大量开销**

| Debug 特性                 | 性能影响          |
| -------------------------- | ----------------- |
| 保留所有变量符号           | 增加栈/堆访问次数 |
| 禁止某些优化（比如内联）   | 避免调试混乱      |
| 增加额外检查（栈溢出检测） | 慢                |

------

###  3. Release 模式利用 CPU 指令集优化（如 `/arch:AVX2`）

- 会使用 **SIMD** 指令（如 AVX/SSE）对数据块并行处理

![release优化](D:\crypto-projects\SM2\release优化.png)

可见吞吐率提升了很多！

# 六、实验结论

1. **SM3 算法结构清晰**，与 SHA-256 相似但更复杂，使用国产 SM3 曲线参数
2. **手写实现易于理解其底层设计**
3. **通过编译器优化和数据结构设计**，性能显著提升至 200+ MB/s
4. **仍有进一步提升空间**，如 SIMD/多线程加速

